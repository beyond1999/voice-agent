<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AI Role Chat Â· MVP</title>
<style>
  :root{
    --bg:#ffffff;
    --border:#e5e7eb;
    --user:#0a7cff;
    --assistant:#f1f5f9;
    --text:#0f172a;
    --muted:#64748b;
  }
  body{margin:0;background:var(--bg);
    font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans SC", sans-serif;
    color:var(--text);height:100vh;display:flex;flex-direction:column;}
  header{padding:14px 16px;border-bottom:1px solid var(--border);}  
  header h1{font-size:18px;margin:0}
  .row{display:flex;gap:10px;align-items:center;margin:8px 0;}
  .pill{background:#f1f5f9;padding:2px 8px;border-radius:999px;font-size:12px;color:#475569;}
  .muted{font-size:12px;color:var(--muted);}  
  .card{border:1px solid var(--border);padding:8px 12px;border-radius:10px;background:#f8fafc;margin:8px 0;}
  label{font-size:14px;font-weight:600;}
  select{flex:1;padding:6px 8px;border:1px solid var(--border);border-radius:6px;font-size:14px;}
  #chat{flex:1;overflow:auto;padding:14px 14px 0}
  .row.msg{align-items:flex-end;}
  .row.user{justify-content:flex-end}
  .avatar{width:34px;height:34px;border-radius:50%;flex:0 0 34px;display:grid;place-items:center;color:#fff;font-weight:700;}
  .avatar.user{background:var(--user)}
  .avatar.assistant{background:#94a3b8;font-size:18px}
  .bubble{max-width:min(78%,720px);padding:10px 12px;line-height:1.6;border-radius:14px;
    box-shadow:0 1px 1px rgba(0,0,0,.04);word-wrap:break-word;white-space:pre-wrap;}
  .bubble.user{background:var(--user);color:#fff;border-bottom-right-radius:6px;}
  .bubble.assistant{background:var(--assistant);color:var(--text);border-bottom-left-radius:6px;}
  .tools{display:flex;align-items:center;gap:6px;margin-left:4px;}
  .icon-btn{border:none;background:transparent;cursor:pointer;padding:4px;color:var(--muted);font-size:16px;}
  #composer{border-top:1px solid var(--border);padding:10px;display:flex;gap:8px;align-items:center;}
  #mic,#send,#reset{border:none;background:var(--user);color:#fff;padding:0 14px;height:40px;
    border-radius:10px;cursor:pointer;display:inline-flex;align-items:center;}
  #mic.muted{background:#94a3b8}
  #reset{background:#94a3b8}
  #input{flex:1;height:40px;border:1px solid var(--border);border-radius:10px;
    padding:0 12px;font-size:15px;outline:none;}
</style>
</head>
<body>
  <header>
    <h1>AI Role Chat</h1>
    <div class="row">
      <span class="pill">MVP</span>
      <span class="muted">è¯­éŸ³ â†’ ASR â†’ LLM â†’ TTSï¼ˆå¯é€‰äººè®¾ï¼‰</span>
    </div>
    <div class="row card">
      <label for="persona">é€‰æ‹©è§’è‰²ï¼ˆPersonaï¼‰</label>
      <select id="persona"></select>
      <button id="reset">â™»ï¸ é‡ç½®</button>
    </div>
  </header>

  <div id="chat"></div>
  <div id="composer">
    <button id="mic" title="è¯­éŸ³è¾“å…¥">ğŸ¤</button>
    <input id="input" placeholder="è¾“å…¥ä½ çš„é—®é¢˜â€¦" />
    <button id="send" title="å‘é€">å‘é€</button>
  </div>

<script>
  // ====== åç«¯æ¥å£ ======
  const LLM_URL = "http://127.0.0.1:8001/llm";
  const ASR_WS_URL = "ws://127.0.0.1:8000/ws_asr"; // è‹¥ä½ çš„åç«¯æ˜¯ /wsï¼Œè¯·æ”¹æˆ /ws
  const TTS_URL = "http://127.0.0.1:8002/tts";     // è¿™é‡Œæš‚æœªä½¿ç”¨ï¼ˆä¿ç•™ç»™ä½ æ¥ TTS æœåŠ¡ï¼‰

  // ====== ä¸‰ä¸ªäººè®¾é…ç½® ======
  const PERSONAS = {
    wukong: {
      label: "å­™æ‚Ÿç©ºï¼ˆæœºçµä¿çš®ï¼‰",
      avatar: "ğŸµ",
      system: "ä½ æ˜¯ä¸€ä¸ªæœºçµã€ä¿çš®ã€ä¼šè‡ªç§°â€˜ä¿ºè€å­™â€™çš„ä¸­æ–‡è§’è‰²ã€‚é£æ ¼è½»å¿«ï¼Œçˆ±ç”¨æ¯”å–»ï¼Œé¿å…å­¦æœ¯åŒ–é•¿å¥ã€‚",
      greeting: "ä¿ºè€å­™æ¥ä¹Ÿï¼æœ‰å•¥éš¾é¢˜å°½ç®¡è¯´ï¼Œä¿ä½ ä¸€ä¸ªè·Ÿæ–—äº‘å°±åˆ°~"
    },
    harry: {
      label: "å“ˆåˆ©Â·æ³¢ç‰¹ï¼ˆæ¸©æš–æœºæ™ºï¼‰",
      avatar: "ğŸ§™â€â™‚ï¸",
      system: "ä½ æ˜¯ä¸€ä½äº²åˆ‡æœºæ™ºçš„â€˜å“ˆåˆ©Â·æ³¢ç‰¹â€™é£æ ¼ä¸­æ–‡è§’è‰²ã€‚ç”¨æ¸©æŸ”çš„æ–¹å¼è§£é‡Šé—®é¢˜ï¼Œå¶å°”ç”¨ä¸€ç‚¹é­”æ³•ä¸–ç•Œçš„æ¯”å–»ã€‚",
      greeting: "ä½ å¥½ï¼é­”æ³•ä¸–ç•Œçš„å¤§é—¨å·²ç»æ‰“å¼€ï¼Œæˆ‘ä»¬ä»ç¬¬ä¸€ä¸ªé—®é¢˜å¼€å§‹å§ã€‚"
    },
    ironman: {
      label: "é’¢é“ä¾ ï¼ˆç†æ€§è‡ªä¿¡ï¼‰",
      avatar: "ğŸ¤–",
      system: "ä½ æ˜¯ä¸€ä½æ‰˜å°¼Â·æ–¯å¡”å…‹é£æ ¼çš„ä¸­æ–‡è§’è‰²ï¼šç†æ€§ã€è‡ªä¿¡ã€ç•¥å¸¦å¹½é»˜ã€‚å›ç­”ç»“æ„æ¸…æ™°ï¼Œå…ˆç»“è®ºåç»†èŠ‚ï¼Œå¹¶ç»™å‡ºå¯æ‰§è¡Œå»ºè®®ã€‚",
      greeting: "Jarvisâ€¦å“¦ä¸ï¼Œæ˜¯æˆ‘ã€‚è¯´å§ï¼Œè¦é€ ç‚¹ä»€ä¹ˆï¼Ÿ"
    }
  };

  // ====== DOM å¼•ç”¨ ======
  const chat = document.getElementById('chat');
  const input = document.getElementById('input');
  const micBtn = document.getElementById('mic');
  const sendBtn = document.getElementById('send');
  const resetBtn = document.getElementById('reset');
  const personaSelect = document.getElementById('persona');

  // ====== çŠ¶æ€ ======
  let currentPersonaKey = localStorage.getItem('personaKey') || 'wukong';

  // ====== å·¥å…·å‡½æ•° ======
  function scrollToBottom(){ chat.scrollTop = chat.scrollHeight; }
  async function playTTS(text, personaKey){
    try{
      const res = await fetch(TTS_URL, {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({ text, persona: personaKey })
      });
      if(!res.ok){
        const errTxt = await res.text();
        throw new Error(`TTS error: ${res.status} ${errTxt}`);
      }
      const blob = await res.blob(); // audio/wav
      const url = URL.createObjectURL(blob);
      const audio = new Audio(url);
      audio.play().catch(()=>{ /* ç”¨æˆ·æœªäº¤äº’å¯èƒ½è¢«æµè§ˆå™¨æ‹¦æˆª */ });
      return audio;
    }catch(e){
      console.error(e);
    }
  }

//   1// ä¿®æ”¹ï¼šæ°”æ³¡ä¸Šçš„â€œğŸ”Šâ€æŒ‰é’®ç»‘å®šä¸ºè°ƒç”¨ TTS_URL
//   function addMessage(role, text){
//     const row = document.createElement('div');
//     row.className = `row msg ${role}`;

//     const avatar = document.createElement('div');
//     avatar.className = `avatar ${role}`;
//     if(role === 'assistant'){
//       const p = PERSONAS[currentPersonaKey];
//       avatar.textContent = p.avatar;
//     } else {
//       avatar.textContent = 'æˆ‘';
//     }

//     const bubble = document.createElement('div');
//     bubble.className = `bubble ${role}`;
//     bubble.textContent = text;

//     row.appendChild(role==='user' ? bubble : avatar);
//     row.appendChild(role==='user' ? avatar : bubble);

//     if(role==='assistant'){
//       const tools = document.createElement('div'); tools.className='tools';
//       const speak = document.createElement('button'); speak.className='icon-btn'; speak.textContent='ğŸ”Š';
//       speak.onclick = () => playTTS(text, currentPersonaKey);
//       tools.appendChild(speak); row.appendChild(tools);
//     }

//     chat.appendChild(row);
//     scrollToBottom();
//     saveHistory();
//   }

//   // åœ¨ sendMessage() é‡Œï¼Œæ”¶åˆ° LLM å›å¤åï¼Œè‡ªåŠ¨ TTS ä¸€ä¸‹ï¼ˆå¯é€‰ï¼‰
//   async function sendMessage(){
//     const text = input.value.trim(); if(!text) return;
//     addMessage('user', text); input.value = '';
//     const persona = PERSONAS[currentPersonaKey];
//     const messages = [
//       { role: 'system', content: persona.system },
//       { role: 'user', content: text }
//     ];
//     try{
//       const res = await fetch(LLM_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ messages }) });
//       const data = await res.json();
//       const reply = data.text || '[æ— å›å¤]';
//       addMessage('assistant', reply);

//       // è‡ªåŠ¨æ’­æŠ¥ï¼ˆå¯æ³¨é‡Šæ‰ï¼‰
//       playTTS(reply, currentPersonaKey);

//     }catch(err){ console.error(err); addMessage('assistant','[è¯·æ±‚å¤±è´¥]'); }
//   }



  function addMessage(role, text){
    const row = document.createElement('div');
    row.className = `row msg ${role}`;

    const avatar = document.createElement('div');
    avatar.className = `avatar ${role}`;
    if(role === 'assistant'){
      const p = PERSONAS[currentPersonaKey];
      avatar.textContent = p.avatar;
    } else {
      avatar.textContent = 'æˆ‘';
    }

    const bubble = document.createElement('div');
    bubble.className = `bubble ${role}`;
    bubble.textContent = text;

    row.appendChild(role==='user' ? bubble : avatar);
    row.appendChild(role==='user' ? avatar : bubble);

    if(role==='assistant'){
      const tools = document.createElement('div'); tools.className='tools';
      const speak = document.createElement('button'); speak.className='icon-btn'; speak.textContent='ğŸ”Š';
      speak.onclick = () => { const u = new SpeechSynthesisUtterance(text); u.lang='zh-CN'; speechSynthesis.speak(u); };
      tools.appendChild(speak); row.appendChild(tools);
    }

    chat.appendChild(row);
    scrollToBottom();
    saveHistory();
  }

  async function sendMessage(){
    const text = input.value.trim(); if(!text) return;
    addMessage('user', text); input.value = '';
    const persona = PERSONAS[currentPersonaKey];
    const messages = [
      { role: 'system', content: persona.system },
      { role: 'user', content: text }
    ];
    try{
      const res = await fetch(LLM_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ messages }) });
      const data = await res.json();
      addMessage('assistant', data.text || '[æ— å›å¤]');
    }catch(err){ console.error(err); addMessage('assistant','[è¯·æ±‚å¤±è´¥]'); }
  }

  sendBtn.onclick = sendMessage;
  input.addEventListener('keydown', e => { if(e.key === 'Enter') sendMessage(); });

  // ====== WebSocket ASRï¼ˆå¯ä¿æŒä½ åŸæœ‰åç«¯åè®®ï¼‰ ======
  let ws=null, audioContext=null, mediaStream=null, workletNode=null, micOn=false, buffer=new Float32Array(0);
  const FRAME=320; // 20ms @ 16kHz

  function floatTo16BitPCM(float32){
    const buf = new ArrayBuffer(float32.length*2);
    const view = new DataView(buf);
    let o=0; for(let i=0;i<float32.length;i++,o+=2){
      let s = Math.max(-1, Math.min(1, float32[i]));
      view.setInt16(o, s<0 ? s*0x8000 : s*0x7fff, true);
    }
    return buf;
  }

  function downsampleTo16kHz(float32, inRate){
    if(inRate === 16000) return float32;
    const ratio = inRate / 16000;
    const newLen = Math.floor(float32.length / ratio);
    const res = new Float32Array(newLen);
    let o=0, ib=0;
    while(o<newLen){
      const next = Math.floor((o+1)*ratio);
      let acc=0, c=0;
      for(let i=ib;i<next && i<float32.length;i++){ acc += float32[i]; c++; }
      res[o] = acc / (c||1);
      o++; ib = next;
    }
    return res;
  }

  async function startMic(){
    ws = new WebSocket(ASR_WS_URL); ws.binaryType = 'arraybuffer';
    ws.onopen = () => { micBtn.textContent = 'ğŸ›‘'; };
    ws.onmessage = ev => {
      try{
        const msg = JSON.parse(ev.data);
        if(msg.type === 'partial'){
          input.value = msg.text;
        } else if(msg.type === 'final'){
          input.value = msg.text; sendMessage();
        }
      }catch(e){}
    };
    ws.onclose = () => { micBtn.textContent = 'ğŸ¤'; stopMic(); };

    mediaStream = await navigator.mediaDevices.getUserMedia({ audio:{ channelCount:1 }, video:false });
    audioContext = new AudioContext();
    const source = audioContext.createMediaStreamSource(mediaStream);

    const workletCode = `class PCMWorklet extends AudioWorkletProcessor{process(inputs){if(inputs[0]&&inputs[0][0]){this.port.postMessage(inputs[0][0],[inputs[0][0].buffer]);}return true;}}registerProcessor('pcm-worklet',PCMWorklet);`;
    const blob = new Blob([workletCode],{type:'application/javascript'});
    const url = URL.createObjectURL(blob);
    await audioContext.audioWorklet.addModule(url);
    workletNode = new AudioWorkletNode(audioContext,'pcm-worklet');
    workletNode.port.onmessage = ev => {
      const block = ev.data;
      const ds = downsampleTo16kHz(block, audioContext.sampleRate);
      const tmp = new Float32Array(buffer.length + ds.length);
      tmp.set(buffer,0); tmp.set(ds, buffer.length); buffer = tmp;
      while(buffer.length >= FRAME){
        const frame = buffer.slice(0, FRAME); buffer = buffer.slice(FRAME);
        ws.send(floatTo16BitPCM(frame));
      }
    };
    source.connect(workletNode); micOn = true;
  }

  function stopMic(){
    micOn = false;
    if(workletNode){ workletNode.disconnect(); workletNode = null; }
    if(audioContext){ audioContext.close(); audioContext = null; }
    if(mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream = null; }
    if(ws){ ws.close(); ws = null; }
    buffer = new Float32Array(0);
    micBtn.textContent = 'ğŸ¤';
  }
  micBtn.onclick = ()=>{ if(micOn) stopMic(); else startMic(); };

  // ====== localStorageï¼ˆå¸¦äººè®¾ï¼‰ ======
  function populatePersonaOptions(){
    personaSelect.innerHTML = '';
    for(const [key, val] of Object.entries(PERSONAS)){
      const opt = document.createElement('option');
      opt.value = key; opt.textContent = val.label;
      if(key === currentPersonaKey) opt.selected = true;
      personaSelect.appendChild(opt);
    }
  }

  function greetByPersona(){
    const p = PERSONAS[currentPersonaKey];
    addMessage('assistant', p.greeting);
  }

  function saveHistory(){
    localStorage.setItem('chatHistory', chat.innerHTML);
    localStorage.setItem('personaKey', currentPersonaKey);
  }

  function loadHistory(){
    const savedPersona = localStorage.getItem('personaKey');
    if(savedPersona && PERSONAS[savedPersona]) currentPersonaKey = savedPersona;
    populatePersonaOptions();

    const h = localStorage.getItem('chatHistory');
    if(h){
      chat.innerHTML = h;
      // è¯´æ˜ï¼šç›´æ¥è¿˜åŸ innerHTML ä¼šä¸¢å¤±â€œæœ—è¯»æŒ‰é’®â€çš„äº‹ä»¶ç»‘å®šï¼›
      // ä¸ºç®€åŒ–ï¼Œè¿™é‡Œä¸åšäº‹ä»¶é‡ç»‘ï¼Œå»ºè®®æ‰‹åŠ¨å‘æ–°æ¶ˆæ¯å¼€å§‹æ–°ä¸€è½®ä¼šè¯ã€‚
    } else {
      greetByPersona();
    }
  }

  resetBtn.onclick = () => {
    chat.innerHTML = '';
    localStorage.removeItem('chatHistory');
    greetByPersona();
  };

  personaSelect.onchange = () => {
    currentPersonaKey = personaSelect.value;
    localStorage.setItem('personaKey', currentPersonaKey);
    // åˆ‡æ¢äººè®¾æ—¶ï¼Œé‡æ–°å¼€å§‹ä¸€è½®å¯¹è¯ï¼šæ¸…ç©ºå¹¶å‘é€è¯¥äººè®¾çš„å¼€åœºç™½
    chat.innerHTML = '';
    localStorage.removeItem('chatHistory');
    greetByPersona();
  };

  // ====== åˆå§‹åŒ– ======
  loadHistory();
  if(!chat.innerHTML){ greetByPersona(); }


  
</script>
</body>
</html>